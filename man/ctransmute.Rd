% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/ctransmute.R
\name{ctransmute}
\alias{ctransmute}
\title{Create and modify columns with Concise notation}
\usage{
ctransmute(.data, ...)
}
\arguments{
\item{.data}{A data frame.}

\item{...}{Any combination of one or more name-value pairs to be evaluated
as columns in the same fashion as in \link[dplyr:mutate]{dplyr::mutate} and two-sided formula
of the form \code{x ~ expr} where \code{x} gives the new name of the column, and \code{expr}
denotes the anonymous function to be iteratively evaluated to create the new
column. As with \link[dplyr:mutate]{dplyr::mutate}, the expression \code{expr} can refer to data
columns in \code{.data} as though they were variables defined in the local scope.}
}
\value{
A data frame containing only the columns created or referenced in the
expressions passed through \code{...}, consistent with the behaviour of
\code{\link[dplyr:transmute]{dplyr::transmute()}}. Grouping variables are preserved.
}
\description{
\code{ctransmute} functions exactly like \link[dplyr:transmute]{dplyr::transmute} with the additional
feature that column definitions specified using a \code{~} instead of \code{=} are
iteratively evaluated as a lambda function. In practice, this works similarly
to using \link[dplyr:rowwise]{dplyr::rowwise} before \link[dplyr:transmute]{dplyr::transmute}, except the result is
calculated much faster and is less computationally expensive, and does so
without overwriting the existing groupings of the data.

Columns defined using a \code{~} also allow for the usage of additional "pronouns"
to concisely refer to related objects or properties of the data columns, such
as row number, groups, as well as the anonymous function itself for use in
recursion.

A \verb{?} following the column definition allows for specifying additional
arguments to pass to the lambda function, as well as the output type of the
column, e.g. integer, character, list, etc.
}
\examples{
tibble::tibble(fruit = list("apple", "banana", NULL, "dragonfruit", NULL)) |>
  ctransmute(fruit_exists ~ !is.null(fruit))

tibble::tibble(x = c(29L, 11L, 72L), y = c(38L, 80L, 98L)) |>
  ctransmute(
    largest ~ max(x, y),
    diff = largest - x
  )

}
